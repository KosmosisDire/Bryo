--- Memory Management ---

extern fn malloc(i32 size) -> void*
extern fn free(void* ptr) -> void
extern fn realloc(void* ptr, i32 size) -> void*
extern fn puts(char* s) -> i32

fn Print(string msg)
{
    puts(msg)
}

fn PrintInt(i32 value)
{
    var buffer = new char[12];  -- Enough for 32-bit int
    IntToString(value, buffer);
    Print(buffer);
}

fn IntToString(i32 num, char* buffer) -> i32
{
    if num == 0
    {
        buffer[0] = (char)48  -- '0' ASCII value
        buffer[1] = (char)0   -- '\0' null terminator
        return 1
    }

    var isNegative = num < 0
    if isNegative
    {
        num = -num  -- Make positive for digit extraction
    }

    var index = 0
    var digit = 0

    -- Extract digits (builds string backwards)
    while num > 0
    {
        digit = num % 10
        buffer[index] = (char)(digit + 48)  -- Convert digit to ASCII ('0' is 48)
        index += 1
        num /= 10
    }

    -- Add negative sign if needed
    if isNegative
    {
        buffer[index] = (char)45  -- '-' ASCII value
        index += 1
    }

    buffer[index] = (char)0  -- Null terminate

    -- Reverse the string in-place
    var start = 0
    var end = index - 1
    char temp = (char)0
    while start < end
    {
        temp = buffer[start]
        buffer[start] = buffer[end]
        buffer[end] = temp
        start += 1
        end -= 1
    }

    return index  -- Return length
}

fn PrintFloat(f32 value)
{
    var buffer = new char[32];  -- Enough for float representation
    FloatToString(value, buffer, 6);  -- 6 decimal places by default
    Print(buffer);
}

fn FloatToString(f32 num, char* buffer, i32 precision) -> i32
{
    var index = 0
    
    -- Handle negative numbers
    if num < 0.0
    {
        buffer[index] = (char)45  -- '-'
        index += 1
        num = -num
    }
    
    -- Extract integer part
    var intPart = (i32)num
    var fracPart = num - (f32)intPart
    
    -- Convert integer part
    var tempBuffer = new char[12]
    var intLen = IntToString(intPart, tempBuffer)
    
    var i = 0
    while i < intLen
    {
        buffer[index] = tempBuffer[i]
        index += 1
        i += 1
    }
    
    -- Add decimal point
    buffer[index] = (char)46  -- '.'
    index += 1
    
    -- Convert fractional part
    var j = 0
    while j < precision
    {
        fracPart *= 10.0
        var digit = (i32)fracPart
        buffer[index] = (char)(digit + 48)
        index += 1
        fracPart -= (f32)digit
        j += 1
    }
    
    buffer[index] = (char)0  -- Null terminate
    return index
}

fn Malloc(i32 size) -> void*
{
    return malloc(size)
}

fn Free(void* ptr)
{
    free(ptr)
}

fn Realloc(void* ptr, i32 newSize) -> void*
{
    return realloc(ptr, newSize)
}

fn Memcpy(void* dest, void* src, i32 size)
{
    char* d = (char*)dest
    char* s = (char*)src
    
    var i = 0
    while i < size
    {
        d[i] = s[i]
        i += 1
    }
}

fn Memset(void* ptr, i32 value, i32 size)
{
    char* p = (char*)ptr
    var val = (char)value
    
    var i = 0
    while i < size
    {
        p[i] = val
        i += 1
    }
}

fn Memcmp(void* a, void* b, i32 size) -> i32
{
    char* pa = (char*)a
    char* pb = (char*)b
    
    var i = 0
    while i < size
    {
        if pa[i] != pb[i]
        {
            if pa[i] < pb[i]
                return -1
            else
                return 1
        }
        i += 1
    }
    
    return 0
}

--- String Utilities ---

fn StrLen(char* s) -> i32
{
    var len = 0
    while s[len] != (char)0
    {
        len += 1
    }
    return len
}

fn StrCopy(char* dest, char* src)
{
    var i = 0
    while src[i] != (char)0
    {
        dest[i] = src[i]
        i += 1
    }
    dest[i] = (char)0
}

fn StrCat(char* dest, char* src)
{
    var destLen = StrLen(dest)
    var i = 0
    while src[i] != (char)0
    {
        dest[destLen + i] = src[i]
        i += 1
    }
    dest[destLen + i] = (char)0
}

fn StrCmp(char* a, char* b) -> i32
{
    var i = 0
    while a[i] != (char)0 && b[i] != (char)0
    {
        if a[i] != b[i]
        {
            if a[i] < b[i]
                return -1
            else
                return 1
        }
        i += 1
    }
    
    -- Check if one string is longer
    if a[i] == (char)0 && b[i] != (char)0
        return -1
    if a[i] != (char)0 && b[i] == (char)0
        return 1
    
    return 0
}

fn StrFind(char* haystack, char* needle) -> i32
{
    var needleLen = StrLen(needle)
    if needleLen == 0
        return 0
    
    var haystackLen = StrLen(haystack)
    var i = 0
    
    while i <= haystackLen - needleLen
    {
        var j = 0
        var matched = true
        
        while j < needleLen
        {
            if haystack[i + j] != needle[j]
            {
                matched = false
                j = needleLen  -- Break out
            }
            j += 1
        }
        
        if matched
            return i
        
        i += 1
    }
    
    return -1  -- Not found
}

fn StrReverse(char* s)
{
    var len = StrLen(s)
    var start = 0
    var end = len - 1
    
    while start < end
    {
        var temp = s[start]
        s[start] = s[end]
        s[end] = temp
        start += 1
        end -= 1
    }
}

fn StrToInt(char* s) -> i32
{
    var result = 0
    var i = 0
    var isNegative = false
    
    -- Skip whitespace
    while s[i] == (char)32 || s[i] == (char)9
    {
        i += 1
    }
    
    -- Check for sign
    if s[i] == (char)45  -- '-'
    {
        isNegative = true
        i += 1
    }
    else if s[i] == (char)43  -- '+'
    {
        i += 1
    }
    
    -- Parse digits
    while s[i] >= (char)48 && s[i] <= (char)57  -- '0' to '9'
    {
        result = result * 10 + ((i32)s[i] - 48)
        i += 1
    }
    
    if isNegative
        return -result
    
    return result
}

fn StrToFloat(char* s) -> f32
{
    var result = 0.0
    var i = 0
    var isNegative = false
    
    -- Skip whitespace
    while s[i] == (char)32 || s[i] == (char)9
    {
        i += 1
    }
    
    -- Check for sign
    if s[i] == (char)45  -- '-'
    {
        isNegative = true
        i += 1
    }
    else if s[i] == (char)43  -- '+'
    {
        i += 1
    }
    
    -- Parse integer part
    while s[i] >= (char)48 && s[i] <= (char)57
    {
        result = result * 10.0 + (f32)((i32)s[i] - 48)
        i += 1
    }
    
    -- Parse decimal part
    if s[i] == (char)46  -- '.'
    {
        i += 1
        var divisor = 10.0
        
        while s[i] >= (char)48 && s[i] <= (char)57
        {
            result = result + (f32)((i32)s[i] - 48) / divisor
            divisor = divisor * 10.0
            i += 1
        }
    }
    
    if isNegative
        return -result
    
    return result
}

fn StrTrim(char* s)
{
    var len = StrLen(s)
    if len == 0
        return
    
    -- Trim end
    var end = len - 1
    while end >= 0 && (s[end] == (char)32 || s[end] == (char)9 || s[end] == (char)10 || s[end] == (char)13)
    {
        end -= 1
    }
    s[end + 1] = (char)0
    
    -- Trim start
    var start = 0
    while s[start] == (char)32 || s[start] == (char)9 || s[start] == (char)10 || s[start] == (char)13
    {
        start += 1
    }
    
    if start > 0
    {
        var i = 0
        while start + i <= end
        {
            s[i] = s[start + i]
            i += 1
        }
        s[i] = (char)0
    }
}

--- Math Utilities ---

fn Abs(i32 x) -> i32
{
    if x < 0
        return -x
    return x
}

fn AbsF(f32 x) -> f32
{
    if x < 0.0
        return -x
    return x
}

fn Min(i32 a, i32 b) -> i32
{
    if a < b
        return a
    return b
}

fn Max(i32 a, i32 b) -> i32
{
    if a > b
        return a
    return b
}

fn MinF(f32 a, f32 b) -> f32
{
    if a < b
        return a
    return b
}

fn MaxF(f32 a, f32 b) -> f32
{
    if a > b
        return a
    return b
}

fn Clamp(i32 x, i32 min, i32 max) -> i32
{
    if x < min
        return min
    if x > max
        return max
    return x
}

fn ClampF(f32 x, f32 min, f32 max) -> f32
{
    if x < min
        return min
    if x > max
        return max
    return x
}

-- Taylor series approximation for sqrt
fn Sqrt(f32 x) -> f32
{
    if x < 0.0
        return 0.0
    
    if x == 0.0
        return 0.0
    
    -- Newton's method
    var guess = x
    var epsilon = 0.00001
    
    var i = 0
    while i < 20
    {
        var newGuess = (guess + x / guess) / 2.0
        if AbsF(newGuess - guess) < epsilon
            return newGuess
        guess = newGuess
        i += 1
    }
    
    return guess
}

fn Floor(f32 x) -> f32
{
    var intPart = (i32)x
    if x < 0.0 && x != (f32)intPart
        return (f32)(intPart - 1)
    return (f32)intPart
}

fn Ceil(f32 x) -> f32
{
    var intPart = (i32)x
    if x > 0.0 && x != (f32)intPart
        return (f32)(intPart + 1)
    return (f32)intPart
}

fn Round(f32 x) -> f32
{
    if x >= 0.0
        return Floor(x + 0.5)
    else
        return Ceil(x - 0.5)
}

fn Pow(f32 base, f32 exp) -> f32
{
    -- Handle special cases
    if exp == 0.0
        return 1.0
    
    if base == 0.0
        return 0.0
    
    -- For integer exponents, use repeated multiplication
    var isNegExp = exp < 0.0
    if isNegExp
        exp = -exp
    
    var result = 1.0
    var intExp = (i32)exp
    
    var i = 0
    while i < intExp
    {
        result = result * base
        i += 1
    }
    
    if isNegExp
        return 1.0 / result
    
    return result
}

fn Lerp(f32 a, f32 b, f32 t) -> f32
{
    return a + (b - a) * t
}

-- Taylor series for sin (limited accuracy)
fn Sin(f32 x) -> f32
{
    var pi = 3.14159265359
    
    -- Normalize to -pi to pi
    while x > pi
    {
        x -= 2.0 * pi
    }
    while x < -pi
    {
        x += 2.0 * pi
    }
    
    -- Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    var result = x
    var term = x
    var x2 = x * x
    
    var i = 1
    while i < 10
    {
        term = -term * x2 / ((f32)(2 * i) * (f32)(2 * i + 1))
        result += term
        i += 1
    }
    
    return result
}

fn Cos(f32 x) -> f32
{
    var pi = 3.14159265359
    
    -- Normalize to -pi to pi
    while x > pi
    {
        x -= 2.0 * pi
    }
    while x < -pi
    {
        x += 2.0 * pi
    }
    
    -- Taylor series: cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...
    var result = 1.0
    var term = 1.0
    var x2 = x * x
    
    var i = 1
    while i < 10
    {
        term = -term * x2 / ((f32)(2 * i - 1) * (f32)(2 * i))
        result += term
        i += 1
    }
    
    return result
}

fn Tan(f32 x) -> f32
{
    var cosVal = Cos(x)
    if AbsF(cosVal) < 0.00001
        return 0.0  -- Avoid division by zero
    
    return Sin(x) / cosVal
}
