extern fn puts(char* s) -> i32

fn Print(string msg)
{
    puts(msg)
}

fn PrintInt(i32 value)
{
    var buffer = new char[12];  -- Enough for 32-bit int
    IntToString(value, buffer);
    Print(buffer);
}

fn IntToString(i32 num, char* buffer) -> i32
{
    if num == 0
    {
        buffer[0] = (char)48  -- '0' ASCII value
        buffer[1] = (char)0   -- '\0' null terminator
        return 1
    }

    var isNegative = num < 0
    if isNegative
    {
        num = -num  -- Make positive for digit extraction
    }

    var index = 0
    var digit = 0

    -- Extract digits (builds string backwards)
    while num > 0
    {
        digit = num % 10
        buffer[index] = (char)(digit + 48)  -- Convert digit to ASCII ('0' is 48)
        index += 1
        num /= 10
    }

    -- Add negative sign if needed
    if isNegative
    {
        buffer[index] = (char)45  -- '-' ASCII value
        index += 1
    }

    buffer[index] = (char)0  -- Null terminate

    -- Reverse the string in-place
    var start = 0
    var end = index - 1
    char temp = (char)0
    while start < end
    {
        temp = buffer[start]
        buffer[start] = buffer[end]
        buffer[end] = temp
        start += 1
        end -= 1
    }

    return index  -- Return length
}

fn PrintFloat(f32 value)
{
    var buffer = new char[32];  -- Enough for float representation
    FloatToString(value, buffer, 6);  -- 6 decimal places by default
    Print(buffer);
}

fn FloatToString(f32 num, char* buffer, i32 precision) -> i32
{
    var index = 0
    
    -- Handle negative numbers
    if num < 0.0
    {
        buffer[index] = (char)45  -- '-'
        index += 1
        num = -num
    }
    
    -- Extract integer part
    var intPart = (i32)num
    var fracPart = num - (f32)intPart
    
    -- Convert integer part
    var tempBuffer = new char[12]
    var intLen = IntToString(intPart, tempBuffer)
    
    var i = 0
    while i < intLen
    {
        buffer[index] = tempBuffer[i]
        index += 1
        i += 1
    }
    
    -- Add decimal point
    buffer[index] = (char)46  -- '.'
    index += 1
    
    -- Convert fractional part
    var j = 0
    while j < precision
    {
        fracPart *= 10.0
        var digit = (i32)fracPart
        buffer[index] = (char)(digit + 48)
        index += 1
        fracPart -= (f32)digit
        j += 1
    }
    
    buffer[index] = (char)0  -- Null terminate
    return index
}