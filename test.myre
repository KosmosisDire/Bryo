
enum Shape
{
    case None
    case Square(int x, int y, int width, int height)
    case Circle(int x, int y, int radius)
}

enum Direction
{
    case North
    case East
    case South
    case West

    fn Opposite() public -> Direction
    {
        match (this)
        {
            .North => .South,
            .East =>
            {
                Console.Log("West")
                return .West
            },
            .South => .North,
            .West => .East,
        }
    }
}

static type Console
{
	messageCount: public mut i32
	doubleVar1: f64 = 2.4
	doubleVar2: f64 = 2.4
	lastMessage: mut string

	fn Log(msg: string) public inline
	{
		Print(msg)
		messageCount++
		lastMessage = msg
	}
	
    // open functions can be overriden
	fn GetLast() public open -> string
	{
		return lastMessage
	}
}

type Vector3
{
	x, y, z: public mut f32

	// An auto implemented constructor is provided if no constructor defined
}

interface type Health
{
    // prop is used to declare a property with a getter and setter.
    // properties can use the field keyword to access a backing field.
    // the field keyword is optional, if not used no auto backing field is created and you must create your own field.
    // Although an auto backing field will be created is the default getter and setter are used.
    health: prop u32
    {
        public get => field
        protected set 
        {
            if (value < 0)
            {
                Console.Log("Health cannot be negative, setting to 0")
                field = 0
            }

            field = value
        }
    }

    // properties with only a getter can be creates with a simple arrow function
    isAlive: public bool => health > 0

    // or
    // isAlive: public bool =>
    // {
    //     return health > 0
    // }
    

    // interfaces can actually define normal variables or constants as well, these must be initialized in the implementation.
    // default values for variables are not allowed in interfaces definitions, only in implementations.
    maxHealth: public mut u32

    // we can define default implementations in an interface and the implementer has to explicitly choose whether to inherit it or not.
    fn TakeDamage(amount: u32) public 
    {
        health -= amount
    }

    // default implementations are not required. This means the derived class MUST implement this function.
    fn Heal(amount: u32) public
}

// Ref types always passed by reference 
ref type Enemy : IHealth
{
	position: public mut Vector3
	attack: i32
	hitChance: f32 = 0.5

    // interfaces are implemented in a nested scope using the `implement` keyword
    implement IHealth
    {
        maxHealth: public u32 = 100
        // use the inherit keyword to use the interface's default property getters and setters
        // health: inherit prop u32 = 100

        // we can also choose to override the default property implementation
        health: prop u32 = 100
        {
            public get => field
            protected set
            {
                match (value)
                {
                    < 0 => {
                        Console.Log("Health cannot be negative, setting to 0")
                        field = 0
                    },
                    > maxHealth => {
                        Console.Log("Health cannot exceed max health, setting to max health")
                        field = maxHealth
                    },
                    _ => {
                        field = value
                    },
                }

                // of course we can also just use a clamp but I wanted to show how to use match
                // field = value.Clamp(0, maxHealth)
            }
        }

        // inherit keyword means that this function will just use the implementation inherited from the interface
        // passdown keyword means that anything that inherits Enemy will have to reimplement this function (they can again choose to inherit or not)
        fn TakeDamage(amount: u32) public inherit passdown;
        
        // implementing the required interface member
        fn Heal(amount: u32)
        {
            health += amount
            if (health > maxHealth)
            {
                health = maxHealth
            }
        }
    }
	
	new(startPos: Vector3, damage: u32 = 5)
	{
		position = startPos
		attack = damage
	}
  
    fn GetDamage() public open -> u32
    {
        PrivateFunc()
	    return Random.Chance(hitChance) ? attack : 0
    }
    
    fn PrivateFunc()
    {
        Console.Log("This is a private function")
    }

    fn PrintStatus() public open
    {
        match (health)
        {
            <= 0 => Console.Log("Enemy is dead"),
            1..10 => Console.Log("Enemy is severely injured"),
            11..50 => Console.Log("Enemy is injured"),
            _ => Console.Log("Enemy is healthy"),
        }
    }

}

fn Main()
{
	running: mut = true
	newvar = "Hello there"
	someVar: mut i32 = 5
	
	while (running)
    {
        someVar++
    }
	
	Console.Log("Done")
}

Main()