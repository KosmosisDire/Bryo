using System;
using System.Collections;

-- File-scoped namespace
namespace TestNamespace;

-- Bracketed namespace
namespace TestBracketed
{
    public fn HelperFunction(): i32
    {
        return 42;
    }
}

-- Simple enum without methods (to avoid match expression issues)
public enum Color
{
    Red,
    Green,
    Blue,
    Alpha(i32 value)
}

-- Enum with simple methods
public enum Status
{
    Active,
    Inactive,
    Pending(string reason),
    
    public fn IsActive(): bool
    {
        -- Simple implementation without match
        return true;
    }
    
    public fn GetCode(): i32
    {
        return 1;
    }
}

-- Static type
public static type Logger
{
    public i32 logCount;
    string lastMessage;
    
    public fn Log(string message)
    {
        lastMessage = message;
        logCount++;
    }
    
    public virtual fn GetLastMessage(): string
    {
        return lastMessage;
    }
}

-- Simple type with various members
public type Point2D
{
    public f32 x;
    public f32 y;
    
    -- Constructor
    new(f32 xPos, f32 yPos)
    {
        x = xPos;
        y = yPos;
    }
    
    public fn Distance(): f32
    {
        return x * x + y * y;
    }
}

-- Type with properties
public type Rectangle
{
    -- Regular fields
    f32 width;

    
    -- Arrow property (getter only)
    public f32 area => width * Height;
    f32 stuff => width * Height;
    
    -- Property with accessor block
    public f32 Width
    {
        get => width;
        set
        {
            if (value > 0)
            {
                width = value;
            }
        }
    }
    
    -- Property with both accessors and backing field with initializer
    public var Height = 1.0
    {
        get
        {
            var stuff = 10.0; -- Local variable
            var things = new Point2D(1.0, 2.0); -- Local object
            return field * stuff + things.x;
        }
        set
        {
            field = value;
        }
    }

    -- Var property with arrow
    public var perimeter => (width + Height) * 2;

    -- Constructor
    new(f32 w, f32 h)
    {
        width = w;
        height = h;
    }
}

-- Abstract type
public abstract type Shape
{
    protected f32 centerX;
    protected f32 centerY;
    
    -- Abstract method
    public abstract fn CalculateArea(): f32;
    
    -- Virtual method with implementation
    public virtual fn GetCenter(): Point2D
    {
        return new Point2D(centerX, centerY);
    }
    
    -- Enforced method
    public enforced fn Move(f32 dx, f32 dy)
    {
        centerX += dx;
        centerY += dy;
    }
}

-- Simple type (inheritance removed)
public type Circle
{
    public f32 radius;
    public f32 centerX;
    public f32 centerY;
    
    new(f32 x, f32 y, f32 r)
    {
        centerX = x;
        centerY = y;
        radius = r;
    }
    
    -- Regular method (override removed)
    public fn CalculateArea(): f32
    {
        return 3.14159 * radius * radius;
    }
    
    -- Regular method (inherit removed)  
    public fn Move(f32 dx, f32 dy)
    {
        centerX += dx;
        centerY += dy;
    }
    
    -- GetCenter method to match abstract Shape interface
    public fn GetCenter(): Point2D
    {
        return new Point2D(centerX, centerY);
    }
}

-- Ref type
public ref type Container
{
    public i32 capacity;
    private i32 count;
    
    new(i32 cap)
    {
        capacity = cap;
        count = 0;
    }
    
    public fn Add(): bool
    {
        if (count < capacity)
        {
            count++;
            return true;
        }
        return false;
    }
    
    public fn GetCount(): i32
    {
        return count;
    }
}

-- Main function to test various statements
fn Main(): i32
{
    -- Variable declarations
    var x = 10;
    var y = 20;
    var message = "Hello World";
    f32 pi = 3.14159;
    bool isReady = true;
    
    -- Type declarations
    i32 counter = 0;
    string name = "Test";
    
    -- Object creation
    var point = new Point2D(1.0, 2.0);
    var rect = new Rectangle(10.0, 20.0);
    var circle = new Circle(0.0, 0.0, 5.0);
    var container = new Container(100);
    
    -- Property access (would be member access in real usage)
    var area = rect.area;
    
    -- Method calls
    var dist = point.Distance();
    var circleArea = circle.CalculateArea();
    container.Add();
    
    -- Control flow - if statements
    if (x > 5)
    {
        y = y + 1;
    }
    
    if (isReady)
    {
        Logger.Log("System is ready");
    }
    else
    {
        Logger.Log("System is not ready");
    }
    
    -- While loop
    while (counter < 10)
    {
        counter++;
        Logger.logCount = counter;
    }
    
    -- For loop (traditional)
    for (i32 t = 0; t < 5; t++)
    {
        if (t < 2)
        {
            continue;
        }

        x = x + t;

        if (x > 20)
        {
            break; -- Exit loop if x exceeds 20
        }
    }

    for (var t2 = 0; t2 < 5; t2++)
    {
        x = x + t2;
    }
    
    -- Nested blocks
    {
        var localVar = 100;
        if (localVar > 50)
        {
            for (var i = 0; i < 3; i++)
            {
                x += i;
            }
        }
    }
    
    -- Expression statements
    x + y;
    point.Distance();
    new Point2D(3.0, 4.0);
    
    -- Assignment expressions
    x = 100;
    y += 50;
    counter *= 2;
    
    -- Logical expressions
    if (x > 50 && y < 100)
    {
        isReady = true;
    }
    
    if (counter == 0 || isReady)
    {
        message = "Condition met";
    }
    
    -- Comparison expressions
    if (x >= y)
    {
        var temp = x;
        x = y;
        y = temp;
    }
    
    -- Arithmetic expressions
    var sum = x + y;
    var diff = x - y;
    var product = x * 2;
    var quotient = y / 2;
    var remainder = x % 3;
    
    -- Unary expressions
    counter++;
    counter--;
    ++counter;
    --counter;
    var negative = -x;
    var notReady = !isReady;
    
    -- Member access chains
    var centerPoint = circle.GetCenter();
    
    -- Range expressions
    var range1 = 0..10;
    var range2 = 5..15 by 2;

    while (counter < 200)
    {
        counter++;
        if (counter == 150)
        {
            break; -- Exit loop when counter reaches 150
        }
    }
    
    -- Return statement
    return 0;
}

-- Call main
Main();

