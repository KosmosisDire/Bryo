using System.Collections;
using Tests;

namespace Test.Namespace;

namespace Test.Bracketed.Namespace
{
    fn Stuff() public -> i32
    {
        return 1
    }

}


enum Shape: public
{
    None
    Square(i32 x, i32 y, i32 width, i32 height)
    Circle(i32 x, i32 y, i32 radius)
}

enum Direction: public
{
    North
    East
    South
    West

    fn Opposite() public -> Direction
    {
        when (this)
        {
            .North => .South,
            .East =>
                {
                    Console.Log("West")
                    return .West
                },
            .South => .North,
            .West => .East,
        }
    }
}

static type Console: public
{
    // members of a static class are implicitly static
	var messageCount: public mut i32
	var doubleVar1: f64 = 2.4
	var doubleVar2: f64 = 2.4
	var lastMessage: mut string

	fn Log(msg: string) public inline
	{
		Print(msg)
		messageCount++
		lastMessage = msg
	}
	
    // virtual functions can be overriden
	fn GetLast() public virtual -> string
	{
		return lastMessage
	}
}

type Vector3: public
{
	var x, y, z: public mut f32

	// An auto implemented constructor is provided if no constructor defined
}

ref type MutableConstraint<T, U>
{
    var value: public mut T

    fn GetValue() public -> T
    {
        return value
    }
}

ref type Observable<T>: public where T : ref type, Updateable, new(i32, i32)
{
    var value: public mut T

    // This is a simple observable that can be used to notify changes
    fn NotifyChange() public
    {
        Console.Log("Value changed to: " + value.ToString())
    }

    fn GetValue() public -> T
    {
        return value
    }
}

type Updateable: public
{
    // This is an interface that can be used to mark types that can be updated
    fn Update(deltaTime: f32) public abstract
}

type Health: public abstract Updateable
{
    // prop is used to declare a property with a getter and setter.
    // properties can use the field keyword to access a backing field.
    // the field keyword is optional, if not used no auto backing field is created and you must create your own field.
    // Although an auto backing field will be created is the default getter and setter are used.
    var health: u32 = 100
    {
        get: public => field
        set: protected =>
        {
            // value is a keyword that refers to the value being set
            if (value < 0)
            {
                Console.Log("Health cannot be negative, setting to 0")
                // field is a keyword that refers to the backing field
                field = 0
            }

            field = value
        }
    }

    // you can also use default access modifiers for properties
    // this will inherit access from the property declaration
    // health: public mut u32 = 100
    //     get => field
    //     set =>
    //     {
    //         if (value < 0)
    //         {
    //             Console.Log("Health cannot be negative, setting to 0")
    //             field = 0
    //         }
    //         field = value
    //     }

    // you can of course also use auto implemented properties
    // health: public mut u32 = 100 {get set}
    // or 
    // health: mut u32 = 100 {get: public set: protected}

    
    
    // properties with only a getter can be creates with a simple arrow function
    // the getter access level matches the level of the property
    var isAlive: public bool => health > 0

    // or
    // isAlive: public bool =>
    // {
    //     return health > 0
    // }
    

    var maxHealth: public mut u32 = 100

    // this function is enforced meaning that any derived class must explicity choose whether to inherit this implementation or define their own implementation
    // This help to make sure that the user of a derived class is aware that this function exists and can choose to override it if needed.
    // This is basically just an abstract function with a default implementation.
    fn TakeDamage(amount: u32) public enforced
    {
        health -= amount
    }

    // default implementations are not required. This means the derived class MUST implement this function.
    // these can only be used in abstract classes.
    fn Heal(amount: u32) public abstract

    // We do nothing by default, but force the derived class to implement this function
    fn Update(deltaTime: f32) public enforced
    {
    }
}

// if I extends health, I must implement the Heal function or choose to inherit the default implementation
type HealthWithRegeneration: public Health
{
    var regenerationRate: public mut f32

    // we must either implement a new TakeDamage function or choose to inherit the default implementation
    // here we choose to inherit the existing implementation
    // if we wanted to override it, we would use the override keyword
    // since we kept the enforced keyword, anything that derives from this class must implement the TakeDamage function the same as here.
    fn TakeDamage(amount: u32) public inherit enforced;

    // here you can see we override the Heal function since it is abstract
    fn Heal(amount: u32) public override
    {
        health += amount
    }

    // we can ommit the enforced function, to allow the derived class to silently inherit this new implementation
    fn Update(deltaTime: f32) public
    {
        health += (regenerationRate * deltaTime)
    }
}

// Ref types always passed by reference 
ref type Enemy: public
{
    var enemies: public static mut List<Enemy> = new List<Enemy>()
    var health: public HealthWithRegeneration
	var position: public mut Vector3
	var attack: i32
	var hitChance: f32 = 0.5
	
	new(startPos: Vector3, damage: u32 = 5)
	{
		position = startPos
		attack = damage
        enemies.Add(this)
	}
  
    fn GetDamage() public enforce -> u32
    {
        PrivateFunc(42, MutableConstraint<Shape, Health>(), (direction: Direction) =>
        {
            return when (direction)
            {
                .North => .Square(0, 0, 10, 10),
                .East => .Circle(0, 0, 5),
                .South => .Square(5, 5, 15, 15),
                .West => .Circle(5, 5, 10),
            }
        })

        // shorthand lambda
        PrivateFunc(42, MutableConstraint<Shape, Health>(), d => .Square(0, 0, 10, 10))

	    return Random.Chance(hitChance) ? attack : 0
    }
    
    fn PrivateFunc(param: i32, bigType: mut MutableConstraint<Shape, Health>, functionParam: fn(Direction) -> Shape) protected virtual -> Observable<Health>
    {
        Console.Log("This is a private function")
        return Observable<Health>(health)
    }

    fn PrintStatus() public virtual
    {
        when
        {
            health <= 0 => Console.Log("Enemy is dead"),
            health in 1..10 => Console.Log("Enemy is severely injured"),
            health in 11..50 => Console.Log("Enemy is injured"),
            _ => Console.Log("Enemy is healthy"),
        }
    }

}

fn Main()
{
	var running: mut = true
	var newvar = "Hello there"
	var someVar: mut i32 = 5
    var floatVar: f32 = 3.14
    var enemy: Enemy = new Enemy(Vector3(0, 0, 0), 10)

    // this is invalid because enemy is not mut
    // enemy = new Enemy(Vector3(1, 1, 1), 20)

    // implicit type inference
    var enemy2: mut = new Enemy(Vector3(1, 1, 1), 20)

    // valid because enemy2 is mut
    enemy2 = new Enemy(Vector3(2, 2, 2), 30)

    for (var e: Enemy in Enemy.enemies)
    {
        e.PrintStatus()
        Console.Log("Enemy damage: " + e.GetDamage().ToString())
    }

    // or type can be inferred
	for (var e in Enemy.enemies)
    {
        e.PrintStatus()
        Console.Log("Enemy damage: " + e.GetDamage().ToString())
    }

    // for i in range
    for (var i: i32 in 0..10)
    {
        Console.Log("Index: " + i.ToString())
    }

    // or type can be inferred
    for (var i in 0..10)
    {
        Console.Log("Index: " + i.ToString())
    }

    // step by 2, "0..10 by 2" is an expression that creates a range from 0 to 10 with a step of 2
    for (var i in 0..10 by 2)
    {
        Console.Log("Index: " + i.ToString())
    }

    // use a variable for range and with a float
    for (var i: f32 in 0.0..floatVar by 0.5)
    {
        Console.Log("Index: " + i.ToString())
    }

    // type can still be inferred
    for (var i in 0..floatVar by 0.5)
    {
        Console.Log("Index: " + i.ToString())
    }

    // subarray with a range
    for (var i in Enemy.enemies[0..2])
    {
        i.PrintStatus()
        Console.Log("Enemy damage: " + i.GetDamage().ToString())
    }

    // subarray with a range
    for (var i in Enemy.enemies[5..10 by 2])
    {
        i.PrintStatus()
        Console.Log("Enemy damage: " + i.GetDamage().ToString())
    }

    // and of course the conventional for loop
    for (var i: i32 = 0; i < 10; i++)
    {
        Console.Log("Index: " + i.ToString())
    }

	while (running)
    {
        someVar++
        if (someVar > 10)
        {
            running = false
        }
    }
	
	Console.Log("Done")
}

Main()