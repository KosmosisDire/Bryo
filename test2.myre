
enum Shape
{
    case None
    case Square(int x, int y, int width, int height)
    case Circle(int x, int y, int radius)
}

enum Direction
{
    case North
    case East
    case South
    case West

    fn Opposite() public -> Direction
    {
        match (this)
        {
            .North => .South,
            .East =>
            {
                Console.Log("West")
                return .West
            },
            .South => .North,
            .West => .East,
        }
    }
}

static type Console
{
	messageCount: public mut i32
	doubleVar1: f64 = 2.4
	doubleVar2: f64 = 2.4
	lastMessage: mut string

	fn Log(msg: string) public inline
	{
		Print(msg)
		messageCount++
		lastMessage = msg
	}
	
    // open functions can be overriden
	fn GetLast() public open -> string
	{
		return lastMessage
	}
}

type Vector3
{
	x, y, z: public mut f32

	// An auto implemented constructor is provided if no constructor defined
}

type Health
{
    // prop is used to declare a property with a getter and setter.
    // properties can use the field keyword to access a backing field.
    // the field keyword is optional, if not used no auto backing field is created and you must create your own field.
    // Although an auto backing field will be created is the default getter and setter are used.
    health: prop u32
    {
        public get => field
        protected set 
        {
            if (value < 0)
            {
                Console.Log("Health cannot be negative, setting to 0")
                field = 0
            }

            field = value
        }
    }

    // properties with only a getter can be creates with a simple arrow function
    isAlive: public bool => health > 0

    // or
    // isAlive: public bool =>
    // {
    //     return health > 0
    // }
    

    maxHealth: public mut u32

    // this function is open meaning it can be overridden in derived classes
    // it is also passdown meaning that any derived class must explicity choose whether to inherit this implementation or define their own implementation
    // This help to make sure that the user of a derived class is aware that this function exists and can choose to override it if needed.
    fn TakeDamage(amount: u32) public open passdown
    {
        health -= amount
    }

    // default implementations are not required. This means the derived class MUST implement this function.
    fn Heal(amount: u32) public abstract
}

// Ref types always passed by reference 
ref type Enemy
{
    health: public Health
	position: public mut Vector3
	attack: i32
	hitChance: f32 = 0.5
	
	new(startPos: Vector3, damage: u32 = 5)
	{
		position = startPos
		attack = damage
	}
  
    fn GetDamage() public open passdown -> u32
    {
        PrivateFunc()
	    return Random.Chance(hitChance) ? attack : 0
    }
    
    fn PrivateFunc()
    {
        Console.Log("This is a private function")
    }

    fn PrintStatus() public open
    {
        match (health)
        {
            <= 0 => Console.Log("Enemy is dead"),
            1..10 => Console.Log("Enemy is severely injured"),
            11..50 => Console.Log("Enemy is injured"),
            _ => Console.Log("Enemy is healthy"),
        }
    }

}

fn Main()
{
	running: mut = true
	newvar = "Hello there"
	someVar: mut i32 = 5
	
	while (running)
    {
        someVar++
        if (someVar > 10)
        {
            running = false
        }
    }
	
	Console.Log("Done")
}

Main()